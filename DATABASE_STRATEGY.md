# Database Strategy: Hybrid Relational & Semantic

## 1. Hybrid Architecture Overview
ARCHIVE-AI utilizes a "Sync-Link" architecture between PostgreSQL and a Vector Database (Pinecone/Milvus). 

*   **PostgreSQL (Source of Truth):** Stores relational data, ownership, file paths, and specific AI attributes (colors, fonts). This handles filtered queries like "Show me all PNGs in the 'Summer Campaign' project."
*   **Vector DB (Semantic Engine):** Stores mathematical embeddings generated by CLIP. This handles conceptual queries like "Show me something with a minimalist vibe."

## 2. Data Synchronization Flow
1.  **Ingestion:** Asset is uploaded -> DB Record created in `assets` table.
2.  **AI Processing:** Worker generates tags (SQL) and embeddings (Vector).
3.  **Indexing:** 
    *   Tags and colors are saved to `asset_tags` and `asset_colors`.
    *   The embedding is saved to the Vector DB using the Postgres `asset_id` as the primary key.
4.  **Retrieval:** 
    *   User searches "minimalist icons."
    *   System converts text to vector.
    *   Vector DB returns top 20 `asset_ids`.
    *   SQL Query: `SELECT * FROM assets WHERE id IN (...) AND org_id = '...'`

## 3. Schema Design Decisions
*   **UUIDs:** Every ID is a UUID to prevent ID collision across distributed microservices and to make Vector DB mapping seamless.
*   **Color Percentages:** Storing hex codes with coverage percentage allows us to build a "Search by Color Palette" feature.
*   **JSONB vs. Structured Tables:** We chose structured tables (`asset_tags`) over JSONB for the tags because it allows for faster aggregation and cross-asset reporting for Creative Directors.

## 4. Scaling Considerations
*   **Read Replicas:** PostgreSQL read replicas will handle the high load of dashboard views.
*   **Namespace Isolation:** Vector DB uses `org_id` metadata filters to ensure one client never sees another client's assets during semantic search.